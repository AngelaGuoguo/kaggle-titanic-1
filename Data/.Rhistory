num <- unlist(str_split(k, ""))[-1]
if (identical(num[1], num[6]) && identical(num[2], num[5]) && identical(num[3], num[4])) {
print(k)
break
}
}
i <- 999
j <- 999
while (i != 0) {
i <- i - 1
k <- i * j
num <- unlist(str_split(k, ""))[-1]
if (identical(num[1], num[6]) && identical(num[2], num[5]) && identical(num[3], num[4])) {
print(k)
break
}
j <- j - 1
k <- i * j
num <- unlist(str_split(k, ""))[-1]
if (identical(num[1], num[6]) && identical(num[2], num[5]) && identical(num[3], num[4])) {
print(k)
break
}
}
sqrt(906)
sqrt(906609)
xtable <- function(x, file = "", ...){
table <- xtable::xtable(x, ...)
print(table, floating = F, hline.after = NULL,
add.to.row = list(pos = list(-1,0, nrow(x)),
command = c('\\toprule\n ','\\midrule\n ','\
\bottomrule\n')),
include.rownames = FALSE, file = file
)
}
length(2:20)
k <- 1
j <- 1
track <- NULL
while (k != 0) {
j <- 1
for (i in 2:20) {
if (k %% i != 0) {
k <- k + 1
}
else {
track[j] <- i
j <- j + 1
print(track)
}
}
if (length(track) == 19) {
print(k)
break
}
}
k <- 1
j <- 1
track <- NULL
while (k != 0) {
j <- 1
for (i in 2:20) {
if (k %% i != 0) {
k <- k + 1
}
if (k %% i == 0) {
track[j] <- i
j <- j + 1
print(track)
if (length(track) == 19) {
print(k)
break
}
}
}
# by all of the numbers from 1 to 20?
k <- 1
j <- 1
track <- NULL
while (k != 0) {
j <- 1
for (i in 2:20) {
if (k %% i != 0) {
k <- k + 1
}
if (k %% i == 0) {
track[j] <- i
j <- j + 1
print(track)
if (length(track) == 19) {
print(k)
break
}
}
}
}
k <- 1
j <- 1
track <- NULL
while (k != 0) {
j <- 1
for (i in 2:20) {
if (k %% i != 0) {
k <- k + 1
}
if (k %% i == 0) {
track[j] <- i
j <- j + 1
}
if (length(track) == 19) {
print(k)
break
}
}
}
k <- 1
j <- 1
track <- NULL
while (k != 0) {
j <- 1
for (i in 2:20) {
if (k %% i != 0) {
k <- k + 1
}
if (k %% i == 0) {
track[j] <- i
j <- j + 1
}
if (length(track) == 19) {
print(k)
break
}
}
}
k <- 2
j <- 1
track <- NULL
while (k != 0) {
j <- 1
for (i in 2:20) {
if (k %% i != 0) {
k <- k + 1
}
if (k %% i == 0) {
track[j] <- i
j <- j + 1
}
if (length(track) == 19) {
print(k)
break
}
}
}
k <- 21
j <- 1
track <- NULL
while (k != 0) {
j <- 1
for (i in 2:20) {
if (k %% i != 0) {
k <- k + 1
}
if (k %% i == 0) {
track[j] <- i
j <- j + 1
}
if (length(track) == 19) {
print(k)
break
}
}
}
k <- 21
j <- 1
track <- NULL
while (k != 0) {
j <- 1
for (i in 20:2) {
if (k %% i != 0) {
k <- k + 1
}
if (k %% i == 0) {
track[j] <- i
j <- j + 1
}
if (length(track) == 19) {
print(k)
break
}
}
}
k <- 1
j <- 1
track <- NULL
while (k != 0) {
j <- 1
for (i in 20:2) {
if (k %% i != 0) {
k <- k + 1
}
if (k %% i == 0) {
track[j] <- i
j <- j + 1
}
if (length(track) == 19) {
print(k)
break
}
}
}
is.prime <- function(x) {
for (i in 2:sqrt(x)) {
if (x %% i == 0) {
print("not prime")
break
}
}
print("prime")
}
is.prime(13)
# Project Euler - Problem 4
# A palindromic number reads the same both ways. The largest palindrome made
# from the product of two 2-digit numbers is 9009 = 91 * 99.
# Find the largest palindrome made from the product of two 3-digit numbers.
library(stringr)
flip <- function(x) {
reverse <- 0
while (x > 0) {
reverse <- (reverse * 10) + (x %% 10)
x <- x/10
}
print(reverse)
}
str_split(123456)
str_split(123456, 3)
str_split(123456, "")
?str_split
str_split(123456, "2")
str_split(123456, "[0-9]")
str_split(123456, "[0-9]?")
str_split(123456, "[0-9]!")
str_split(123456, "[:digit:]")
str_split(123456, [:digit:])
str_split(123456, "[:digit:]")
str_split(123456, "[:digit:][:digit:]")
str_split(123456, "[:digit:][:digit:][:digit:]")
str_split(123456, "[:digit:]")
?str_split
?strsplit
str_split(123456)
str_split(123456, "")
str_split(123456, )
str_split(123456, NULL)
str_split(123456, "")[[1]]
str_split(123456, "")[[1]][1]
str_split(123456, "")[[1]][-1]
str_split(123456, "")[[1]][-1]
str_split(123456, "")[[1]][-1]
flip <- function(x) {
x <- str_split(x, "")[[1]][-1]
x <- x[length(x):1]
}
flip <- function(x) {
x <- str_split(x, "")[[1]][-1]
print(x[length(x):1])
}
flip(123456)
flip <- function(x) {
x <- str_split(x, "")[[1]][-1]
x <- as.numeric(x[length(x):1])
}
flip(123456)
flip <- function(x) {
x <- str_split(x, "")[[1]][-1]
x <- as.numeric(x[length(x):1])
print(x)
}
flip(123)
str_split(123456, "")[[1]][-1]
x <- str_split(x, "")[[1]][-1]
y <- as.numeric(x[length(x):1])
y
x <- str_split(123456, "")[[1]][-1]
y <- as.numeric(x[length(x):1])
y
as.numeric(x[length(x):1])
x[length(x):1]
as.numeric(x[length(x):1])
?as.numeric
as.integer(x[length(x):1])
str_merge
str_combine
?stringr
str_c((x[length(x):1])
)
x[length(x):1]
str_c(as.numeric(x[length(x):1]))
?str_c
?paste
paste(as.numeric(x[length(x):1]))
str_c(as.numeric(x[length(x):1]), collapse = "")
str_c(x[length(x):1], collapse = "")
as.numeric(str_c(x[length(x):1], collapse = ""))
flip <- function(x) {
x <- str_split(x, "")[[1]][-1]
flipped <- as.numeric(str_c(x[length(x):1], collapse = ""))
print(flipped)
}
flip(12345)
isPalindromic <- function(x) {
if (x == flip(x)) {
print(TRUE)
}
else {
print(FALSE)
}
}
isPalindromic(123321)
flip <- function(x) {
x <- str_split(x, "")[[1]][-1]
flipped <- as.numeric(str_c(x[length(x):1], collapse = ""))
print(flipped)
}
flip(x)
flip(123456)
isPal <- function(x) {
if (x == flip(x)) {
print(TRUE)
}
else {
print(FALSE)
}
}
is.pal <- function(x) {
if (x == flip(x)) {
print(TRUE)
}
else {
print(FALSE)
}
}
is.pal(123)
flip <- function(x) {
x <- str_split(x, "")[[1]][-1]
flipped <- as.numeric(str_c(x[length(x):1], collapse = ""))
return(flipped)
}
is.pal <- function(x) {
if (x == flip(x)) {
print(TRUE)
}
else {
print(FALSE)
}
}
is.pal(123)
is.pal <- function(x) {
if (x == flip(x)) {
return(TRUE)
}
else {
return(FALSE)
}
}
is.pal(123)
is.logical(is.pal(123))
is.pal <- function(x) {
if (x == flip(x)) {
return(TRUE)
}
else {
return(FALSE)
}
}
is.palindromic <- function(x) {
x <- unlist(str_split(x, ""))[-1]
if (identical(x[1], x[6]) && identical(x[2], x[5]) && identical(x[3], x[4])) {
return(as.logical("TRUE"))
}
else {
return(as.logical("FALSE"))
}
}
max <- 0
product <- 0
for(i in 100:999) {
for (j in 100:i) {
product <- i * j
if (is.pal(product) == TRUE && product > max) {
max <- product
print(max)
}
}
}
max <- 0
product <- 0
for(i in 999:100) {
for (j in i:100) {
product <- i * j
if (is.pal(product) == TRUE && product > max) {
max <- product
print(max)
}
}
}
install.packages("sp")
library(sp)
train <- read.csv("train.csv", stringsAsFactors = F)  # 891 obs
setwd("C:/Users/matt/kaggle-titanic/Data")
source(helpers.R)
source(helpers.R)
source("helpers.R")
# baisc randomForest model (aka baby's first randomForest)
library(randomForest)
source("helpers.R")
train <- read.csv("train.csv", stringsAsFactors = F)  # 891 obs
test <- read.csv("test.csv", stringsAsFactors = F)    # 418 obs
###
### Clean the data set before running randomForest
###
# Replace missing values in AGE and FARE with mean
train$age[is.na(train$age)] <- mean(train$age)
train$fare[is.na(train$fare)] <- mean(train$fare)
test$age[is.na(test$age)] <- mean(test$age)
test$fare[is.na(test$fare)] <- mean(test$fare)
# Convert survived, sex & embarked to factors
train$sex <- factor(train$sex)
train$embarked <- factor(train$sex)
train$survived <- factor(train$survived)
test$sex <- factor(test$sex)
test$embarked <- factor(test$embarked)
###
### Create randomForest object and make prediction
###
# Create forest without name, ticket, cabin, or embarked
forest <- randomForest(factor(survived) ~ . -name -ticket -cabin -embarked,
data = train_tidy,
ntree = 5000,
importance=TRUE)
# baisc randomForest model (aka baby's first randomForest)
library(randomForest)
source("helpers.R")
train <- read.csv("train.csv", stringsAsFactors = F)  # 891 obs
test <- read.csv("test.csv", stringsAsFactors = F)    # 418 obs
###
### Clean the data set before running randomForest
###
# Replace missing values in AGE and FARE with mean
train$age[is.na(train$age)] <- mean(train$age)
train$fare[is.na(train$fare)] <- mean(train$fare)
test$age[is.na(test$age)] <- mean(test$age)
test$fare[is.na(test$fare)] <- mean(test$fare)
# Convert survived, sex & embarked to factors
train$sex <- factor(train$sex)
train$embarked <- factor(train$sex)
train$survived <- factor(train$survived)
test$sex <- factor(test$sex)
test$embarked <- factor(test$embarked)
###
### Create randomForest object and make prediction
###
# Create forest without name, ticket, cabin, or embarked
forest <- randomForest(factor(survived) ~ . -name -ticket -cabin -embarked,
data = train,
ntree = 5000,
importance=TRUE)
train$age[is.na(train$age)] <- mean(train$age, na.rm = TRUE)
train$fare[is.na(train$fare)] <- mean(train$fare, na.rm = TRUE)
test$age[is.na(test$age)] <- mean(test$age, na.rm = TRUE)
test$fare[is.na(test$fare)] <- mean(test$fare, na.rm = TRUE))
train$age[is.na(train$age)] <- mean(train$age, na.rm = TRUE)
train$fare[is.na(train$fare)] <- mean(train$fare, na.rm = TRUE)
test$age[is.na(test$age)] <- mean(test$age, na.rm = TRUE)
test$fare[is.na(test$fare)] <- mean(test$fare, na.rm = TRUE)
forest <- randomForest(factor(survived) ~ . -name -ticket -cabin -embarked,
data = train,
ntree = 5000,
importance=TRUE)
rmse(forest, test)
rmse(forest, train)
test$survived <- predict(forest, test, type = "class")
rmse(forest, test)
train <- read.csv("train.csv", stringsAsFactors = F)  # 891 obs
test <- read.csv("test.csv", stringsAsFactors = F)    # 418 obs
train <- read.csv("train.csv", stringsAsFactors = F)  # 891 obs
test <- read.csv("test.csv", stringsAsFactors = F)    # 418 obs
###
### Clean the data set before running randomForest
###
# Replace missing values in AGE and FARE with mean
train$age[is.na(train$age)] <- mean(train$age, na.rm = TRUE)
train$fare[is.na(train$fare)] <- mean(train$fare, na.rm = TRUE)
test$age[is.na(test$age)] <- mean(test$age, na.rm = TRUE)
test$fare[is.na(test$fare)] <- mean(test$fare, na.rm = TRUE)
str(train)
forest <- randomForest(factor(survived) ~ factor(sex) + age + fare,
data = train,
ntree = 5000,
importance=TRUE)
train$sex
forest <- randomForest(factor(survived) ~ factor(sex) + age + fare,
data = train,
ntree = 5000,
importance=TRUE)
forest <- randomForest(factor(survived) ~ age + fare,
data = train,
ntree = 5000,
importance=TRUE)
rsme(forest, train)
source("helpers.R")
rsme(forest, train)
rmse(forest, train)
